Contract Address: 0xd3fd63209fa2d55b07a0f6db36c2f43900be3094
Source File: 526_0xd3fd63209fa2d55b07a0f6db36c2f43900be3094.sol
Audit Date: 2026-01-14T19:23:04.705Z
Model: gpt-4.1

================================ AUDIT RESULT ================================

Critical Vulnerability: ðŸš¨ YES

Summary:
The Savingcoin contract's deposit and withdrawal logic does not use or transfer the asset ERC20 tokens in accordance with the ERC4626 standard; instead, it calls token burning and minting functions (via IStablecoin) directly. This allows any user to permanently lock all assets deposited, as the contract never actually receives the deposited ERC20 tokens, and the _withdraw path tries to mint tokens instead of transferring them out. Thus, a user can deposit and receive shares, but will never be able to withdraw, causing permanent fund lock.

Attack Surface: ERC20


Critical Issues Found:

1. Permanent Lock of Deposited ERC20 Assets
   Type: Permanent fund lock due to non-standard asset transfer logic
   Function: _deposit, _withdraw
   
   Attack Scenario:
   A user deposits their ERC20 asset via deposit or mint. The contract calls IStablecoin(asset()).burnFrom instead of actually transferring the ERC20 from the user to itself (or the vault). The asset contract, if not a custom burnable/mintable stablecoin, does not burn tokens and the vault receives no assets. On withdrawal, the contract attempts to mint the asset token out of nowhere to the user (IStablecoin(asset()).mint), which a generic ERC20 will not support. If the underlying asset is not an IStablecoin that supports arbitrary burning/minting by this contract, users deposit assets that are fully and permanently lost, as the vault never becomes the custodian of the user's assets and cannot return them.
   
   Impact:
   All user ERC20 assets deposited into the contract are permanently lost and unrecoverable, constituting a permanent fund-lock vulnerability.
   
   Recommended Fix:
   Strictly follow the ERC4626 deposit/withdrawal conventions: use SafeERC20.safeTransferFrom to receive asset tokens on deposit, and SafeERC20.safeTransfer to payout tokens on withdrawal, instead of custom burn/mint calls. Only use burnFrom/mint if absolutely certain you are interacting with a mintable/burnable asset, and the contract has the correct minting/burning rights.



==============================================================================

Raw JSON:
{
  "critical_vulnerability_exists": true,
  "summary": "The Savingcoin contract's deposit and withdrawal logic does not use or transfer the asset ERC20 tokens in accordance with the ERC4626 standard; instead, it calls token burning and minting functions (via IStablecoin) directly. This allows any user to permanently lock all assets deposited, as the contract never actually receives the deposited ERC20 tokens, and the _withdraw path tries to mint tokens instead of transferring them out. Thus, a user can deposit and receive shares, but will never be able to withdraw, causing permanent fund lock.",
  "attack_surface": [
    "ERC20"
  ],
  "critical_issues": [
    {
      "title": "Permanent Lock of Deposited ERC20 Assets",
      "vulnerability_type": "Permanent fund lock due to non-standard asset transfer logic",
      "affected_function": "_deposit, _withdraw",
      "attack_scenario": "A user deposits their ERC20 asset via deposit or mint. The contract calls IStablecoin(asset()).burnFrom instead of actually transferring the ERC20 from the user to itself (or the vault). The asset contract, if not a custom burnable/mintable stablecoin, does not burn tokens and the vault receives no assets. On withdrawal, the contract attempts to mint the asset token out of nowhere to the user (IStablecoin(asset()).mint), which a generic ERC20 will not support. If the underlying asset is not an IStablecoin that supports arbitrary burning/minting by this contract, users deposit assets that are fully and permanently lost, as the vault never becomes the custodian of the user's assets and cannot return them.",
      "impact": "All user ERC20 assets deposited into the contract are permanently lost and unrecoverable, constituting a permanent fund-lock vulnerability.",
      "recommended_fix": "Strictly follow the ERC4626 deposit/withdrawal conventions: use SafeERC20.safeTransferFrom to receive asset tokens on deposit, and SafeERC20.safeTransfer to payout tokens on withdrawal, instead of custom burn/mint calls. Only use burnFrom/mint if absolutely certain you are interacting with a mintable/burnable asset, and the contract has the correct minting/burning rights."
    }
  ]
}
