Contract Address: 0x881d40237659c251811cec9c364ef91dc08d300c
Source File: 4_0x881d40237659c251811cec9c364ef91dc08d300c.sol
Audit Date: 2026-01-15T14:00:58.750Z
Model: gpt-4.1

================================ AUDIT RESULT ================================

Critical Vulnerability: ðŸš¨ YES

Summary:
Several adapters and MetaSwap contract components introduce exploit paths for general users, primarily via arbitrary contract call/delegatecall, lack of input/output accounting, weak trust boundaries, and bad handling of fee and asset transfers. These allow arbitrary external call execution, loss or theft of funds, and fund lockup by any user who crafts malicious aggregation routes, adapters, or aggregator addresses. Further, the WETH adapters can be abused for ETH/WETH draining attacks and value extraction. Key invariants (like input/output or fee guarantees) are broken by design and can be exploited for critical economic attacks.


Critical Issues Found:

1. Arbitrary Delegatecall from Spender allows Storage Corruption and Full Contract Takeover
   Type: Arbitrary Delegatecall
   Function: swap, _delegate
   
   Attack Scenario:
   A user registering a malicious contract as an 'adapter' allows execution of attacker-provided code in the Spender context using delegatecall, since any non-owner user can trigger Spender.swap (via MetaSwap._swap()). This means any malicious aggregator may execute arbitrary bytecode, including overwriting storage, stealing tokens/ETH, disabling the contract, or breaking all invariants. This fully compromises the Spender and potentially the entire MetaSwap system.
   
   Impact:
   Full loss of all Spender contract funds, storage corruption, denial of service, arbitrary code execution, or disabling all further swaps. Any asset/tokens previously transferred to Spender by users can be stolen instantly.
   
   Recommended Fix:
   undefined


2. Arbitrary External Call to Aggregator (Arbitrary Call Injection)
   Type: Unrestricted External Call
   Function: swap
   
   Attack Scenario:
   The swap() function in all adapter contracts allows the caller to specify any aggregator address and arbitrary bytes to call via functionCallWithValue with arbitrary msg.value. A user can provide a malicious aggregator contract (potentially selfdestructing, draining funds, reentering, or causing DoS).
   
   Impact:
   Draining of all contract ETH/tokens, full asset loss, lockup of funds, or gas griefing due to reentrancy, out-of-gas, or failure to guard execution. Attackers can route ETH/tokens to themselves or break business logic assumptions, including reentrancy into adapters.
   
   Recommended Fix:
   undefined


3. Broken Input/Output Accounting Enables Fund Draining or Forced Losses
   Type: Lack of Robust Accounting (Arbitrary Output Transfer)
   Function: swap,_transfer
   
   Attack Scenario:
   swap() functions in adapters send all of their current balance for tokenFrom and tokenTo (not carefully metered to the user-supplied amount), and send all contract ETH after swap completion. A user may front-run or sandwich their own swap to make the contract hold more of any token/ETH, allowing the next swap to drain the pool or funds to their own recipient.
   
   Impact:
   Draining of tokens/ETH beyond what was expected or authorized by the system, theft of previous usersâ€™ tokens accidentally left in the contract, or unwanted/unfair redistribution across users. Manipulation of output accounting via front-running, reentrancy, or by controlling the contract state.
   
   Recommended Fix:
   undefined


4. Lack of Validation for Required Input Amount Enables Value Extraction from Contract State
   Type: Missing Swap Input/Output Validation
   Function: swap
   
   Attack Scenario:
   swap() in adapters does not validate that amountTo is reasonably linked to input amountFrom, nor that the contract held only solely the correct input and no excess tokens. Adversaries may manipulate swaps so that the adapter accumulates tokens (via accidental transfers, failed swaps with tokens left behind, or direct transfers from malicious users), and then launch a swap that steals all available tokens/ETH in the contractâ€”beyond their own swap input.
   
   Impact:
   Theft of tokens, unfair redistribution across users, contract draining, and disruption of fair exchange by general users. This is especially critical if tokens/ETH are unknowingly left in the contract as 'dust'â€”the next swap drains them.
   
   Recommended Fix:
   undefined



==============================================================================
