Contract Address: 0x04571c32a4e1c5f39bc3a238cb95b215058c432c
Source File: 123_0x04571c32a4e1c5f39bc3a238cb95b215058c432c.sol
Audit Date: 2026-01-15T15:26:58.032Z
Model: gpt-4.1

================================ AUDIT RESULT ================================

Critical Vulnerability: ðŸš¨ YES

Summary:
The contract exposes multiple critical vulnerabilities and business logic flaws that can be exploited by unprivileged users, especially around initial share minting and share calculation, flash loan repay conditions, and lack of input validation for amounts. These enable severe economic attacks, fund extraction, and broken invariant scenarios.


Critical Issues Found:

1. First LP Can Mint Shares to Address(0) and Steal Protocol Value
   Type: Business Logic Vulnerability / Value Extraction
   Function: buyShares, sellShares
   
   Attack Scenario:
   In the 'buyShares' function, when totalSupply == 0, the first LP's call will mint 1001 shares to address(0). However, future calculations for mint ratios and redemptions still include totalSupply, so the lost shares (address(0)) result in higher proportional value for the first LP, allowing them to extract PoR > 100% when later selling shares. This is known as the DODO 'first LP mint bug': the first LP can get nearly all protocol assets by burning their shares, siphoning off funds paid by later LPs.
   
   Impact:
   Unprivileged user can extract all protocol value after being the first LP, resulting in loss of all assets from subsequent LPs.
   
   Recommended Fix:
   undefined


2. Share Calculation Rounding and Value Extraction
   Type: Economic Attack / Invariant Break
   Function: buyShares,sellShares
   
   Attack Scenario:
   Share minting (buyShares) and burning (sellShares) use integer math which, coupled with rounding and precise updates to _BASE_TARGET_ and _QUOTE_TARGET_, enables repeated 'dust' extraction when minting/burning in small increments. Attacker can mint/burn minimal shares in tight loops, causing value drift and extracting more than their fair share.
   
   Impact:
   Gradual fund extraction by repeated mint/burn cycles. Potential for total value loss over time (griefing/extraction).
   
   Recommended Fix:
   undefined


3. Potential Loss of Funds via Empty Minting (Dust Share Lock)
   Type: Fund Lockup / Economic Attack
   Function: buyShares
   
   Attack Scenario:
   The minimum mint amount check in _mint (require(value > 1000)) is only present for share creation, but 'buyShares' subtracts 1001 from the calculated shares for the first LP, allowing future unmintable (too small) shares to remain in the contract, resulting in stuck assets with no way to recover them.
   
   Impact:
   Dust funds become permanently locked in contract, reducing total LP value.
   
   Recommended Fix:
   undefined


4. Reentrancy via Arbitrary External Call in sellShares (IDODOCallee)
   Type: Reentrancy / External Call to Arbitrary Address
   Function: sellShares
   
   Attack Scenario:
   After assets are transferred to `to`, the contract calls IDODOCallee(to).DVMSellShareCall. If `to` is a user/attacker contract, it can reenter via e.g. sync() or any external/public function, possibly breaking assumptions or draining further funds.
   
   Impact:
   Potential arbitrary state manipulation, DoS, or asset extraction depending on other function accessibility and invariants.
   
   Recommended Fix:
   undefined


5. Permit Function Signature Malleability and Replay
   Type: Signature Replay / Permit Abuse
   Function: permit
   
   Attack Scenario:
   The permit function increments nonces only after digest calculation, enabling replay if a user copies input with the old nonce. Also, domain separator is mutable with buildDomainSeparator(). This allows attackers to replay permits with same nonce if the separator changes.
   
   Impact:
   Unprivileged attackers can steal ERC20 approvals in certain scenarios or block users from securely permitting.
   
   Recommended Fix:
   undefined


6. FlashLoan Repayment Inconsistency (Partial Repay Allowed)
   Type: Broken Invariant / Fund Extraction
   Function: flashLoan
   
   Attack Scenario:
   The flashLoan function only requires baseBalance >= _BASE_RESERVE_ or quoteBalance >= _QUOTE_RESERVE_ (not both). This allows attacker to take flash loans and only repay one side, permanently extracting unbalanced tokens for free.
   
   Impact:
   Unlimited protocol asset extraction from one side via repeated flash loans.
   
   Recommended Fix:
   undefined



==============================================================================
