const fs = require('fs').promises;
const path = require('path');
const logger = require('./logger');

/**
 * Report Generator - Creates human-readable audit reports
 */

/**
 * Generate a human-readable markdown report for a single contract audit
 * @param {Object} auditResults - Audit results object
 * @param {string} outputPath - Output file path
 * @returns {Promise<string>} Path to generated report
 */
async function generateContractReport(auditResults, outputPath) {
  try {
    const { contractAddress, timestamp, auditors, summary, duration } = auditResults;
    
    let report = '';
    
    // Header
    report += `# Smart Contract Audit Report\n\n`;
    report += `**Contract Address:** \`${contractAddress}\`\n\n`;
    report += `**Audit Date:** ${new Date(timestamp).toLocaleString()}\n\n`;
    report += `**Total Duration:** ${duration}ms\n\n`;
    report += `---\n\n`;
    
    // Executive Summary
    report += `## Executive Summary\n\n`;
    report += `| Metric | Count |\n`;
    report += `|--------|-------|\n`;
    report += `| Total Auditors | ${summary.totalAuditors} |\n`;
    report += `| Successful Audits | ${summary.successfulAudits} |\n`;
    report += `| Failed Audits | ${summary.failedAudits} |\n`;
    report += `| **Total Findings** | **${summary.totalFindings}** |\n`;
    report += `| ðŸ”´ Critical | ${summary.criticalFindings} |\n`;
    report += `| ðŸŸ  High | ${summary.highFindings} |\n`;
    report += `| ðŸŸ¡ Medium | ${summary.mediumFindings} |\n`;
    report += `| ðŸŸ¢ Low | ${summary.lowFindings} |\n`;
    report += `| â„¹ï¸ Info | ${summary.infoFindings} |\n\n`;
    
    // Risk Assessment
    const riskLevel = calculateRiskLevel(summary);
    const riskEmoji = getRiskEmoji(riskLevel);
    report += `**Overall Risk Level:** ${riskEmoji} **${riskLevel.toUpperCase()}**\n\n`;
    report += `---\n\n`;
    
    // Detailed Findings by Auditor
    for (const [auditorName, auditorResults] of Object.entries(auditors)) {
      report += `## ${auditorResults.auditor} Results\n\n`;
      
      if (!auditorResults.success) {
        report += `âŒ **Audit Failed:** ${auditorResults.error}\n\n`;
        continue;
      }
      
      if (auditorResults.findings.length === 0) {
        report += `âœ… **No vulnerabilities detected**\n\n`;
        continue;
      }
      
      // Group findings by severity
      const findingsBySeverity = groupBySeverity(auditorResults.findings);
      
      for (const severity of ['critical', 'high', 'medium', 'low', 'info']) {
        const findings = findingsBySeverity[severity] || [];
        if (findings.length === 0) continue;
        
        const emoji = getSeverityEmoji(severity);
        report += `### ${emoji} ${severity.charAt(0).toUpperCase() + severity.slice(1)} Severity (${findings.length})\n\n`;
        
        findings.forEach((finding, index) => {
          report += `#### ${index + 1}. ${finding.id}\n\n`;
          report += `**Title:** ${finding.title}\n\n`;
          report += `**Confidence:** ${finding.confidence}\n\n`;
          
          if (finding.description) {
            report += `**Description:**\n\n`;
            report += `${finding.description}\n\n`;
          }
          
          if (finding.recommendation) {
            report += `**Recommendation:**\n\n`;
            report += `${finding.recommendation}\n\n`;
          }
          
          if (finding.locations && finding.locations.length > 0) {
            report += `**Locations:**\n\n`;
            finding.locations.forEach(loc => {
              report += `- \`${loc.file}\``;
              if (loc.startLine) {
                report += ` (Line ${loc.startLine}`;
                if (loc.endLine && loc.endLine !== loc.startLine) {
                  report += `-${loc.endLine}`;
                }
                report += `)`;
              }
              report += `\n`;
            });
            report += `\n`;
          }
          
          if (finding.references && finding.references.length > 0) {
            report += `**References:**\n\n`;
            finding.references.forEach(ref => {
              report += `- ${ref}\n`;
            });
            report += `\n`;
          }
          
          report += `---\n\n`;
        });
      }
      
      // Metadata
      if (auditorResults.metadata) {
        report += `### Audit Metadata\n\n`;
        report += `- **Auditor Version:** ${auditorResults.metadata.version || 'unknown'}\n`;
        report += `- **Solc Version:** ${auditorResults.metadata.solcVersion || 'default'}\n`;
        report += `- **Duration:** ${auditorResults.metadata.duration || 'N/A'}ms\n`;
        report += `- **Timestamp:** ${new Date(auditorResults.timestamp).toLocaleString()}\n\n`;
      }
    }
    
    // Footer
    report += `---\n\n`;
    report += `*Report generated by audit-bot on ${new Date().toLocaleString()}*\n`;
    
    // Write report to file
    await fs.writeFile(outputPath, report, 'utf8');
    logger.debug(`Report generated: ${outputPath}`);
    
    return outputPath;
    
  } catch (error) {
    logger.error(`Failed to generate report: ${error.message}`);
    throw error;
  }
}

/**
 * Generate a summary dashboard of all audits
 * @param {string} resultsDir - Directory containing audit results
 * @param {string} outputPath - Output file path
 * @returns {Promise<string>} Path to generated summary
 */
async function generateSummaryDashboard(resultsDir, outputPath) {
  try {
    // Read all summary files
    const files = await fs.readdir(resultsDir);
    const summaryFiles = files.filter(f => f.endsWith('.summary.json'));
    
    const allResults = [];
    for (const file of summaryFiles) {
      try {
        const content = await fs.readFile(path.join(resultsDir, file), 'utf8');
        const summaryData = JSON.parse(content);
        // Reconstruct minimal result structure for dashboard
        allResults.push({
          contractAddress: summaryData.contractAddress,
          timestamp: summaryData.timestamp,
          summary: summaryData.summary,
          duration: summaryData.duration,
          auditors: {} // Not needed for dashboard summary
        });
      } catch (error) {
        logger.debug(`Skipping invalid file: ${file}`);
      }
    }
    
    // Sort by timestamp (most recent first)
    allResults.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    let dashboard = '';
    
    // Header
    dashboard += `# ðŸ›¡ï¸ Smart Contract Audit Dashboard\n\n`;
    dashboard += `**Last Updated:** ${new Date().toLocaleString()}\n\n`;
    dashboard += `**Total Contracts Audited:** ${allResults.length}\n\n`;
    dashboard += `---\n\n`;
    
    // Overall Statistics
    const overallStats = calculateOverallStats(allResults);
    
    dashboard += `## ðŸ“Š Overall Statistics\n\n`;
    dashboard += `| Metric | Value |\n`;
    dashboard += `|--------|-------|\n`;
    dashboard += `| Total Contracts | ${overallStats.totalContracts} |\n`;
    dashboard += `| Total Findings | ${overallStats.totalFindings} |\n`;
    dashboard += `| ðŸ”´ Critical | ${overallStats.criticalFindings} |\n`;
    dashboard += `| ðŸŸ  High | ${overallStats.highFindings} |\n`;
    dashboard += `| ðŸŸ¡ Medium | ${overallStats.mediumFindings} |\n`;
    dashboard += `| ðŸŸ¢ Low | ${overallStats.lowFindings} |\n`;
    dashboard += `| â„¹ï¸ Info | ${overallStats.infoFindings} |\n`;
    dashboard += `| Average Findings/Contract | ${(overallStats.totalFindings / Math.max(overallStats.totalContracts, 1)).toFixed(1)} |\n\n`;
    
    // Risk Distribution
    dashboard += `## ðŸŽ¯ Risk Distribution\n\n`;
    const riskDistribution = calculateRiskDistribution(allResults);
    dashboard += `| Risk Level | Count | Percentage |\n`;
    dashboard += `|------------|-------|------------|\n`;
    Object.entries(riskDistribution).forEach(([level, count]) => {
      const percentage = ((count / Math.max(allResults.length, 1)) * 100).toFixed(1);
      const emoji = getRiskEmoji(level);
      dashboard += `| ${emoji} ${level.charAt(0).toUpperCase() + level.slice(1)} | ${count} | ${percentage}% |\n`;
    });
    dashboard += `\n`;
    
    // Top Vulnerabilities
    dashboard += `## ðŸ” Most Common Vulnerabilities\n\n`;
    const topVulnerabilities = getTopVulnerabilities(allResults, 10);
    if (topVulnerabilities.length > 0) {
      dashboard += `| # | Vulnerability | Occurrences | Avg Severity |\n`;
      dashboard += `|---|---------------|-------------|-------------|\n`;
      topVulnerabilities.forEach((vuln, index) => {
        const emoji = getSeverityEmoji(vuln.avgSeverity);
        dashboard += `| ${index + 1} | ${vuln.id} | ${vuln.count} | ${emoji} ${vuln.avgSeverity} |\n`;
      });
      dashboard += `\n`;
    } else {
      dashboard += `*No vulnerabilities detected across all contracts*\n\n`;
    }
    
    // Group contracts by risk level
    const contractsByRisk = {
      'critical': [],
      'high': [],
      'medium': [],
      'low': [],
      'info': [],
      'none': []
    };
    
    allResults.forEach(result => {
      const riskLevel = calculateRiskLevel(result.summary);
      contractsByRisk[riskLevel].push(result);
    });
    
    // Contract Audit Summary grouped by risk level
    dashboard += `## ðŸ“‹ Contract Audit Summary\n\n`;
    
    // Display contracts grouped by risk level (in order of severity)
    const riskOrder = ['critical', 'high', 'medium', 'low', 'info', 'none'];
    
    riskOrder.forEach(riskLevel => {
      const contracts = contractsByRisk[riskLevel];
      if (contracts.length === 0) return;
      
      const riskEmoji = getRiskEmoji(riskLevel);
      const riskLabel = riskLevel.charAt(0).toUpperCase() + riskLevel.slice(1);
      
      dashboard += `### ${riskEmoji} ${riskLabel} Risk (${contracts.length} contracts)\n\n`;
      dashboard += `| Contract Address | Findings | Critical | High | Medium | Low | Last Audit |\n`;
      dashboard += `|------------------|----------|----------|------|--------|-----|------------|\n`;
      
      // Sort by total findings (descending) within each risk group
      contracts.sort((a, b) => b.summary.totalFindings - a.summary.totalFindings);
      
      contracts.forEach(result => {
        const fullAddress = result.contractAddress.toLowerCase();
        const auditDate = new Date(result.timestamp).toLocaleDateString();
        
        dashboard += `| \`${fullAddress}\` | ${result.summary.totalFindings} | `;
        dashboard += `${result.summary.criticalFindings} | ${result.summary.highFindings} | `;
        dashboard += `${result.summary.mediumFindings} | ${result.summary.lowFindings} | ${auditDate} |\n`;
      });
      dashboard += `\n`;
    });
    
    // Legend
    dashboard += `---\n\n`;
    dashboard += `## ðŸ“– Legend\n\n`;
    dashboard += `**Risk Levels:**\n`;
    dashboard += `- ðŸ”´ **Critical:** Multiple critical/high severity issues\n`;
    dashboard += `- ðŸŸ  **High:** High severity issues present\n`;
    dashboard += `- ðŸŸ¡ **Medium:** Medium severity issues only\n`;
    dashboard += `- ðŸŸ¢ **Low:** Low/Info issues only\n`;
    dashboard += `- âšª **None:** No issues detected\n\n`;
    
    dashboard += `**Severity Levels:**\n`;
    dashboard += `- ðŸ”´ Critical: Exploitable vulnerabilities with severe impact\n`;
    dashboard += `- ðŸŸ  High: Significant security issues\n`;
    dashboard += `- ðŸŸ¡ Medium: Moderate security concerns\n`;
    dashboard += `- ðŸŸ¢ Low: Minor issues and best practice violations\n`;
    dashboard += `- â„¹ï¸ Info: Informational findings\n\n`;
    
    // Footer
    dashboard += `---\n\n`;
    dashboard += `*Dashboard auto-generated by audit-bot*\n`;
    dashboard += `*This file is updated in real-time after each audit*\n`;
    
    // Write dashboard to file
    await fs.writeFile(outputPath, dashboard, 'utf8');
    logger.info(`ðŸ“Š Summary dashboard updated: ${outputPath}`);
    
    return outputPath;
    
  } catch (error) {
    logger.error(`Failed to generate summary dashboard: ${error.message}`);
    throw error;
  }
}

/**
 * Helper function to group findings by severity
 */
function groupBySeverity(findings) {
  const groups = {};
  findings.forEach(finding => {
    const severity = finding.severity.toLowerCase();
    if (!groups[severity]) {
      groups[severity] = [];
    }
    groups[severity].push(finding);
  });
  return groups;
}

/**
 * Calculate risk level based on findings
 */
function calculateRiskLevel(summary) {
  if (summary.criticalFindings > 0) return 'critical';
  if (summary.highFindings > 0) return 'high';
  if (summary.mediumFindings > 0) return 'medium';
  if (summary.lowFindings > 0) return 'low';
  if (summary.infoFindings > 0) return 'info';
  return 'none';
}

/**
 * Get emoji for risk level
 */
function getRiskEmoji(riskLevel) {
  const emojis = {
    'critical': 'ðŸ”´',
    'high': 'ðŸŸ ',
    'medium': 'ðŸŸ¡',
    'low': 'ðŸŸ¢',
    'info': 'â„¹ï¸',
    'none': 'âšª'
  };
  return emojis[riskLevel.toLowerCase()] || 'â“';
}

/**
 * Get emoji for severity
 */
function getSeverityEmoji(severity) {
  const emojis = {
    'critical': 'ðŸ”´',
    'high': 'ðŸŸ ',
    'medium': 'ðŸŸ¡',
    'low': 'ðŸŸ¢',
    'info': 'â„¹ï¸',
    'informational': 'â„¹ï¸',
    'optimization': 'âš¡'
  };
  return emojis[severity.toLowerCase()] || 'â“';
}

/**
 * Calculate overall statistics
 */
function calculateOverallStats(allResults) {
  return {
    totalContracts: allResults.length,
    totalFindings: allResults.reduce((sum, r) => sum + r.summary.totalFindings, 0),
    criticalFindings: allResults.reduce((sum, r) => sum + r.summary.criticalFindings, 0),
    highFindings: allResults.reduce((sum, r) => sum + r.summary.highFindings, 0),
    mediumFindings: allResults.reduce((sum, r) => sum + r.summary.mediumFindings, 0),
    lowFindings: allResults.reduce((sum, r) => sum + r.summary.lowFindings, 0),
    infoFindings: allResults.reduce((sum, r) => sum + r.summary.infoFindings, 0)
  };
}

/**
 * Calculate risk distribution
 */
function calculateRiskDistribution(allResults) {
  const distribution = {
    'critical': 0,
    'high': 0,
    'medium': 0,
    'low': 0,
    'info': 0,
    'none': 0
  };
  
  allResults.forEach(result => {
    const riskLevel = calculateRiskLevel(result.summary);
    distribution[riskLevel]++;
  });
  
  return distribution;
}

/**
 * Get top vulnerabilities across all contracts
 */
function getTopVulnerabilities(allResults, limit = 10) {
  const vulnerabilityCounts = {};
  
  allResults.forEach(result => {
    Object.values(result.auditors).forEach(auditor => {
      if (auditor.findings) {
        auditor.findings.forEach(finding => {
          if (!vulnerabilityCounts[finding.id]) {
            vulnerabilityCounts[finding.id] = {
              id: finding.id,
              count: 0,
              severities: []
            };
          }
          vulnerabilityCounts[finding.id].count++;
          vulnerabilityCounts[finding.id].severities.push(finding.severity);
        });
      }
    });
  });
  
  // Calculate average severity for each vulnerability
  const vulnerabilities = Object.values(vulnerabilityCounts).map(vuln => {
    const avgSeverityNum = vuln.severities.reduce((sum, s) => sum + severityToNumber(s), 0) / vuln.severities.length;
    return {
      id: vuln.id,
      count: vuln.count,
      avgSeverity: numberToSeverity(avgSeverityNum)
    };
  });
  
  // Sort by count (most common first), then by severity
  return vulnerabilities
    .sort((a, b) => {
      if (b.count !== a.count) return b.count - a.count;
      return severityToNumber(b.avgSeverity) - severityToNumber(a.avgSeverity);
    })
    .slice(0, limit);
}

/**
 * Convert severity to number for sorting
 */
function severityToNumber(severity) {
  const map = {
    'critical': 5,
    'high': 4,
    'medium': 3,
    'low': 2,
    'info': 1,
    'informational': 1,
    'optimization': 0
  };
  return map[severity.toLowerCase()] || 0;
}

/**
 * Convert number back to severity
 */
function numberToSeverity(num) {
  if (num >= 4.5) return 'critical';
  if (num >= 3.5) return 'high';
  if (num >= 2.5) return 'medium';
  if (num >= 1.5) return 'low';
  return 'info';
}

module.exports = {
  generateContractReport,
  generateSummaryDashboard
};
